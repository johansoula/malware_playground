#!/usr/bin/python -u
import base64
import re
import sys
import json
import hashlib
import gc
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

pcap_data = dict()

def pkts_handler(p):
    # Gather packet info to identify flow (src_ip + src_port + dst_ip + tcp_syn_cookie)
    src_ip =  p.payload.src # src_ip
    dst_ip =  p.payload.dst # dst_ip
    time = int(p.time)   # timestamp (epoch)
    seq = p.seq          # tcp seq number
    uid = str(time) + str(seq) # uid = timestamp + seq number , to sort out of order packet

    print "Packet UID: " + uid
    out_file = src_ip + "_" + dst_ip + "_" + str(p.sport) + "_raw_flow_"
    try:
    	payload = p.payload.load 

    	# hard coded filter to keep only smtp traffic (port 25)
    	if not (out_file in pcap_data):
        	pcap_data[out_file] = dict()
    	pcap_data[out_file][uid] = payload
    except:
	pass 

# Take pcap filename in input
# Return dict (flows => list of packets)
def smtp_data_from_pcap(filename):
    print "Opening PCAP: " + filename 
    #Gather packet in a dictionary key= flow output file
    #sniff(offline=filename, prn=pkts_handler, filter="dst tcp port 25", store=0, timeout=30)
    # instead of sniff offline, reading pcap... but we could sniff for 30 seconds a live interface
    packets = rdpcap(filename)
    for p in packets:
        pkts_handler(p)


def parse_raw_email(email_output, sender_filters, logfile):
    file_types = re.compile(r'\.(doc|xls)', re.IGNORECASE)
    #open file for reading
    fh = open(email_output, "r")
    #Get first line to check sender
    line = fh.readline()
    mail_from = re.search(r'MAIL FROM:<([^>]+)>', line)

    #We will check only emails from external sources
    if mail_from == None:
        return None
        
        #filtering on senders
    for sender in sender_filters:
        if re.search(sender, mail_from.group(1)):
            return None
        else:
            pass
        #Init variables (used later for pretty print)
        email = mail_from.group(1)
        recipients=" "
        filename = None
        #Init raw SMTP email reading
        start = 0             #parsing id
        encoded_buf = ""      #buffer will be used for base64 attachment decode
        for line in fh.xreadlines():
            if start == 0:
                match = re.search(r'RCPT TO:<([^>]+)>', line)
                if match:
                    recipients += match.group(1)
                    recipients += " "
                    continue

                match = re.search(r'name="*([^"\r\n]+)', line)
                if match and file_types.search(match.group(1)):
                    start = 1
                    filename = match.group(1)
                    continue

            if start > 0 and re.search(r'^--', line):
                start = 0
                try:
                    decoded_buf = base64.b64decode(encoded_buf)
                    file_save = open("working_dir/" + filename, "w")
                    file_save.write(decoded_buf)
                    file_save.close
                    
                    fd_hash = open("hashes.log", "aw")
                    print("file=\"%s\" sha1=%s sha256=%s md5=%s" % ( filename,
                                                                                                hashlib.sha1(decoded_buf).hexdigest(),
                                                                                                hashlib.sha256(decoded_buf).hexdigest(),
                                                                                                hashlib.md5(decoded_buf).hexdigest(),
                                                                             ))
                    fd_hash.write("file=\"%s\" sha1=%s sha256=%s md5=%s sender=\"%s\" recipient=\"%s\"\r\n" % ( filename, 
                                                                                                hashlib.sha1(decoded_buf).hexdigest(), 
                                                                                                hashlib.sha256(decoded_buf).hexdigest(),
                                                                                                hashlib.md5(decoded_buf).hexdigest(),
                                                                                                email, 
                                                                                                recipients
                                                                             )
                    )
                    fd_hash.close

                except:
                    pass

                encoded_buf = ""
                filename = None
                continue

            if start > 0:
                match = re.search(r'^([0-9a-zA-Z+/=]+)\s*$', line)
                if match:
                    encoded_buf += line

        fh.close


def save_raw_email(email_output):
    fh = open(email_output, "aw")
    fh.write(chunk)
    fh.close



#MAIN
if len(sys.argv) < 2:
    sys.exit(1)

#Open PCAP file and store flow in dictionnary
in_file = sys.argv[1]
smtp_data_from_pcap(in_file)

#Iterate on each flow to extract and parse raw e-mail
mid = 0
for out_file in pcap_data:
        #Sort packets by timestamp + tcp seq number
        data = sorted(pcap_data[out_file])
	print "Just sorted flow: " + out_file
        sys.stdout.flush()
	emails_list = set()

        for uid in data:
            chunk = pcap_data[out_file][uid]
            if re.search("MAIL FROM:", chunk):
                mid += 1
            email_output = out_file + str(mid)
            save_raw_email(email_output)
            emails_list.add(email_output)
        del data

        #Iterate over all emails found (set)
        sender_filters = [  "@myacme.com" ]
        for email_output in emails_list:
            parse_raw_email(email_output, sender_filters, in_file + ".log") # parse e-mail and extract attchment
	    os.remove(email_output) #to be commented for debug

sys.exit(0)
